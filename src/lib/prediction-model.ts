import { prisma } from './db'
import { GRID_SIZE, REGIONS } from './constants'
import { FirePrediction } from '@/types/fire'

interface WeatherFeatures {
  temperature: number
  humidity: number
  windSpeed: number
  windDirection: number
  precipitation: number
}

interface HistoricalFeatures {
  fireCount7Days: number
  fireCount30Days: number
  avgConfidence: number
  maxFRP: number
  dayNightRatio: number
}

interface SeasonalFeatures {
  month: number
  dayOfYear: number
  isHarvestSeason: boolean
  daysFromHarvestStart: number
}

interface GridFeatures extends WeatherFeatures, HistoricalFeatures, SeasonalFeatures {
  latitude: number
  longitude: number
  elevation?: number
  landUse?: string
  agriculturalArea: boolean
}

export class FirePredictionModel {
  private modelWeights: Record<string, number> = {
    // Weather features
    temperature: 0.15,
    humidity: -0.12,
    windSpeed: 0.08,
    precipitation: -0.18,
    // Historical features
    fireCount7Days: 0.25,
    fireCount30Days: 0.15,
    avgConfidence: 0.10,
    maxFRP: 0.08,
    // Seasonal features
    isHarvestSeason: 0.30,
    daysFromHarvestStart: -0.05,
    // Geographic features
    agriculturalArea: 0.20,
    // Bias
    bias: -0.02
  }

  async generatePredictions(
    region: 'punjab' | 'haryana',
    predictionDate: Date,
    horizonDays: number = 7
  ): Promise<FirePrediction[]> {
    const regionBounds = REGIONS[region].bounds
    const predictions: FirePrediction[] = []

    // Generate grid points
    const gridPoints = this.generateGridPoints(regionBounds)

    console.log(`Generating predictions for ${gridPoints.length} grid points`)

    for (const point of gridPoints) {
      try {
        const features = await this.extractFeatures(
          point.lat,
          point.lng,
          predictionDate,
          horizonDays
        )

        const probability = this.predictFireProbability(features)
        const confidence = this.calculateConfidence(features)

        if (probability > 0.1) { // Only store predictions above threshold
          const prediction: FirePrediction = {
            id: '', // Will be generated by database
            grid_lat: point.lat,
            grid_lng: point.lng,
            probability,
            confidence,
            prediction_date: predictionDate.toISOString().split('T')[0],
            prediction_horizon: horizonDays,
            model_version: '1.0',
            features: JSON.stringify(features),
            created_at: new Date()
          }

          predictions.push(prediction)
        }
      } catch (error) {
        console.error(`Error generating prediction for ${point.lat}, ${point.lng}:`, error)
        continue
      }
    }

    // Store predictions in database
    await this.storePredictions(predictions)

    return predictions
  }

  private generateGridPoints(bounds: typeof REGIONS.punjab.bounds) {
    const points: { lat: number; lng: number }[] = []
    
    for (let lat = bounds.south; lat <= bounds.north; lat += GRID_SIZE) {
      for (let lng = bounds.west; lng <= bounds.east; lng += GRID_SIZE) {
        points.push({ lat: Number(lat.toFixed(4)), lng: Number(lng.toFixed(4)) })
      }
    }
    
    return points
  }

  private async extractFeatures(
    lat: number,
    lng: number,
    predictionDate: Date,
    horizonDays: number
  ): Promise<GridFeatures> {
    const tolerance = GRID_SIZE / 2

    // Historical features
    const historical = await this.getHistoricalFeatures(lat, lng, tolerance, predictionDate)
    
    // Weather features (in a real implementation, you'd fetch from weather API)
    const weather = await this.getWeatherFeatures(lat, lng, predictionDate)
    
    // Seasonal features
    const seasonal = this.getSeasonalFeatures(predictionDate)
    
    // Geographic features
    const geographic = this.getGeographicFeatures(lat, lng)

    return {
      latitude: lat,
      longitude: lng,
      ...weather,
      ...historical,
      ...seasonal,
      ...geographic
    }
  }

  private async getHistoricalFeatures(
    lat: number,
    lng: number,
    tolerance: number,
    predictionDate: Date
  ): Promise<HistoricalFeatures> {
    const date7DaysAgo = new Date(predictionDate.getTime() - 7 * 24 * 60 * 60 * 1000)
    const date30DaysAgo = new Date(predictionDate.getTime() - 30 * 24 * 60 * 60 * 1000)

    const [fires7Days, fires30Days] = await Promise.all([
      prisma.fireDetection.findMany({
        where: {
          latitude: { gte: lat - tolerance, lte: lat + tolerance },
          longitude: { gte: lng - tolerance, lte: lng + tolerance },
          acq_date: { gte: date7DaysAgo.toISOString().split('T')[0] }
        }
      }),
      prisma.fireDetection.findMany({
        where: {
          latitude: { gte: lat - tolerance, lte: lat + tolerance },
          longitude: { gte: lng - tolerance, lte: lng + tolerance },
          acq_date: { gte: date30DaysAgo.toISOString().split('T')[0] }
        }
      })
    ])

    const avgConfidence = fires30Days.length > 0
      ? fires30Days.reduce((sum, fire) => sum + fire.confidence, 0) / fires30Days.length
      : 0

    const maxFRP = fires30Days.length > 0
      ? Math.max(...fires30Days.map(fire => fire.frp))
      : 0

    const dayFires = fires30Days.filter(fire => fire.daynight === 'D').length
    const nightFires = fires30Days.filter(fire => fire.daynight === 'N').length
    const dayNightRatio = nightFires > 0 ? dayFires / nightFires : dayFires

    return {
      fireCount7Days: fires7Days.length,
      fireCount30Days: fires30Days.length,
      avgConfidence,
      maxFRP,
      dayNightRatio
    }
  }

  private async getWeatherFeatures(lat: number, lng: number, date: Date): Promise<WeatherFeatures> {
    // In a real implementation, you would fetch from a weather API
    // For now, we'll use simplified seasonal patterns based on Punjab/Haryana climate
    
    const month = date.getMonth() + 1
    const dayOfYear = this.getDayOfYear(date)
    
    // Simplified weather modeling for stubble burning season (Oct-Dec)
    let temperature = 25 // Base temperature in Celsius
    let humidity = 60 // Base humidity percentage
    let windSpeed = 10 // Base wind speed in km/h
    let precipitation = 0 // Base precipitation in mm
    
    // Adjust for season
    if (month >= 10 && month <= 12) { // Stubble burning season
      temperature = 22 - (month - 10) * 3 // Decreasing temperature
      humidity = 65 - (month - 10) * 5 // Decreasing humidity
      windSpeed = 8 + (month - 10) * 2 // Increasing wind
      precipitation = Math.max(0, 5 - (month - 10) * 2) // Decreasing precipitation
    }
    
    // Add some randomness for grid variation
    temperature += (Math.random() - 0.5) * 6
    humidity += (Math.random() - 0.5) * 20
    windSpeed += (Math.random() - 0.5) * 5
    precipitation += Math.random() * 2
    
    return {
      temperature: Math.max(0, temperature),
      humidity: Math.max(0, Math.min(100, humidity)),
      windSpeed: Math.max(0, windSpeed),
      windDirection: Math.random() * 360,
      precipitation: Math.max(0, precipitation)
    }
  }

  private getSeasonalFeatures(date: Date): SeasonalFeatures {
    const month = date.getMonth() + 1
    const dayOfYear = this.getDayOfYear(date)
    
    // Harvest season in Punjab/Haryana: mid-October to mid-December
    const isHarvestSeason = month >= 10 && month <= 12
    const harvestStartDay = this.getDayOfYear(new Date(date.getFullYear(), 9, 15)) // Oct 15
    const daysFromHarvestStart = isHarvestSeason ? dayOfYear - harvestStartDay : 0

    return {
      month,
      dayOfYear,
      isHarvestSeason,
      daysFromHarvestStart: Math.max(0, daysFromHarvestStart)
    }
  }

  private getGeographicFeatures(lat: number, lng: number) {
    // Simplified geographic features
    // In a real implementation, you would use GIS data
    
    // Punjab and Haryana are heavily agricultural
    const agriculturalArea = true
    
    return {
      agriculturalArea,
      elevation: 200 + Math.random() * 100, // Approximate elevation range
      landUse: 'agricultural'
    }
  }

  private predictFireProbability(features: GridFeatures): number {
    let score = this.modelWeights.bias || 0

    // Weather contribution
    score += (features.temperature - 20) * 0.01 * this.modelWeights.temperature
    score += (60 - features.humidity) * 0.01 * this.modelWeights.humidity
    score += features.windSpeed * 0.01 * this.modelWeights.windSpeed
    score += (5 - features.precipitation) * 0.1 * this.modelWeights.precipitation

    // Historical contribution
    score += features.fireCount7Days * this.modelWeights.fireCount7Days
    score += features.fireCount30Days * 0.1 * this.modelWeights.fireCount30Days
    score += features.avgConfidence * 0.01 * this.modelWeights.avgConfidence
    score += Math.min(features.maxFRP, 1000) * 0.001 * this.modelWeights.maxFRP

    // Seasonal contribution
    score += (features.isHarvestSeason ? 1 : 0) * this.modelWeights.isHarvestSeason
    score += Math.min(features.daysFromHarvestStart, 60) * 0.01 * this.modelWeights.daysFromHarvestStart

    // Geographic contribution
    score += (features.agriculturalArea ? 1 : 0) * this.modelWeights.agriculturalArea

    // Convert to probability using sigmoid function
    return 1 / (1 + Math.exp(-score))
  }

  private calculateConfidence(features: GridFeatures): number {
    // Confidence based on data availability and feature strength
    let confidence = 0.5 // Base confidence
    
    // Increase confidence if we have historical data
    if (features.fireCount30Days > 0) confidence += 0.2
    if (features.fireCount7Days > 0) confidence += 0.2
    
    // Increase confidence during harvest season
    if (features.isHarvestSeason) confidence += 0.3
    
    // Decrease confidence for extreme weather conditions (less reliable)
    if (features.precipitation > 10) confidence -= 0.2
    if (features.temperature < 10 || features.temperature > 40) confidence -= 0.1
    
    return Math.max(0.1, Math.min(1.0, confidence))
  }

  private async storePredictions(predictions: FirePrediction[]) {
    // Clear old predictions for the same date and horizon
    if (predictions.length > 0) {
      const samplePrediction = predictions[0]
      await prisma.firePrediction.deleteMany({
        where: {
          prediction_date: samplePrediction.prediction_date,
          prediction_horizon: samplePrediction.prediction_horizon
        }
      })
    }

    // Store new predictions in batches
    const batchSize = 100
    for (let i = 0; i < predictions.length; i += batchSize) {
      const batch = predictions.slice(i, i + batchSize)
      await prisma.firePrediction.createMany({
        data: batch.map(p => ({
          grid_lat: p.grid_lat,
          grid_lng: p.grid_lng,
          probability: p.probability,
          confidence: p.confidence,
          prediction_date: p.prediction_date,
          prediction_horizon: p.prediction_horizon,
          model_version: p.model_version,
          features: JSON.stringify(p.features)
        }))
      })
    }
  }

  private getDayOfYear(date: Date): number {
    const start = new Date(date.getFullYear(), 0, 0)
    const diff = date.getTime() - start.getTime()
    return Math.floor(diff / (1000 * 60 * 60 * 24))
  }

  async getPredictions(
    region: 'punjab' | 'haryana',
    predictionDate: string,
    horizonDays: number = 7
  ): Promise<FirePrediction[]> {
    const regionBounds = REGIONS[region].bounds
    
    const results = await prisma.firePrediction.findMany({
      where: {
        grid_lat: { gte: regionBounds.south, lte: regionBounds.north },
        grid_lng: { gte: regionBounds.west, lte: regionBounds.east },
        prediction_date: predictionDate,
        prediction_horizon: horizonDays
      },
      orderBy: [
        { probability: 'desc' }
      ]
    })

    return results.map(result => ({
      ...result,
      features: typeof result.features === 'string' ? result.features : JSON.stringify(result.features)
    }))
  }
}

export function createPredictionModel(): FirePredictionModel {
  return new FirePredictionModel()
}